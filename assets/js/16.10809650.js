(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{325:function(v,_,e){"use strict";e.r(_);var t=e(0),d=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"nodejs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nodejs","aria-hidden":"true"}},[v._v("#")]),v._v(" Nodejs")]),v._v(" "),e("h2",{attrs:{id:"学习-node-js-的三个境界"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#学习-node-js-的三个境界","aria-hidden":"true"}},[v._v("#")]),v._v(" 学习 Node.js 的三个境界")]),v._v(" "),e("p",[v._v("我总结的编程3种境界")]),v._v(" "),e("ul",[e("li",[v._v("打日志：console.log")]),v._v(" "),e("li",[v._v("断点调试：断点调试：node debugger 或node inspector 或vscode")]),v._v(" "),e("li",[v._v("测试驱动开发（tdd | bdd）")])]),v._v(" "),e("p",[v._v("大家可以自测一下，自己在哪个水平？如果是第三个阶段，那么本场Live可能不太适合你。哈哈哈")]),v._v(" "),e("p",[v._v("本教程适合nodejs入门级别，循环渐进，慢慢深入学习！")]),v._v(" "),e("h2",{attrs:{id:"如何学习node-js"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何学习node-js","aria-hidden":"true"}},[v._v("#")]),v._v(" 如何学习Node.js")]),v._v(" "),e("p",[v._v("Node不是语言，不是框架，只是基于V8运行时环境。结合libuv能够通过js语法获得更好的等价于c/c++的性能。")]),v._v(" "),e("p",[v._v("它很简单，异步是解决并发的最佳实践。")]),v._v(" "),e("h3",{attrs:{id:"基础学习"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础学习","aria-hidden":"true"}},[v._v("#")]),v._v(" 基础学习")]),v._v(" "),e("p",[v._v("1）js语法必须会")]),v._v(" "),e("ol",[e("li",[v._v("js基本语法，都是c语系的，有其他语言背景学习起来相对更简单")]),v._v(" "),e("li",[v._v("常见用法，比如正则，比如数据结构，尤其是数组的几种用法。比如bind/call/apply等等")]),v._v(" "),e("li",[v._v("面向对象写法。js是基于对象的，所以它的oo写起来非常诡异。参见红皮书JavaScript高级编程，很多框架都是自己实现oo基础框架，比如ext-core等。")])]),v._v(" "),e("p",[v._v("犀牛书，《JavaScript权威指南》，没事就多翻翻，看少多少遍都不为过。")]),v._v(" "),e("p",[v._v("2）个人学习和技术选型都要循序渐进")]),v._v(" "),e("ol",[e("li",[v._v("先能写，采用面向过程写法，简单理解就是定义一堆function，然后调用，非常简单")]),v._v(" "),e("li",[v._v("然后再追求更好的写法，可以面向对象。对于规模化的编程来说，oo是有它的优势的，一般java、c#，ruby这些语言里都有面向对象，所以后端更习惯，但对于语言经验不那么强的前端来说算高级技巧。")]),v._v(" "),e("li",[v._v("等oo玩腻了，可以有更好的追求：函数式编程，无论编程思维，还是用法上都对已有的编程思维是个挑战。我很喜欢函数式，但不太会在团队里使用，毕竟oo阶段还没完全掌握，风险会比较大。但如果团队水平都非常高了，团队稳定是可以用的。")])]),v._v(" "),e("p",[v._v("可以看出我的思路，先能写，然后再追求更好的写法，比如面向对象。等团队水平到一定程度了，并且稳定的时候，可以考虑更加极致的函数式写法。")]),v._v(" "),e("p",[v._v("团队是这样选型的，个人学习也这样，最好是循序渐进，步子迈大了不好。")]),v._v(" "),e("p",[v._v("3）各种高级的JavaScript友好语言")]),v._v(" "),e("p",[v._v("JavaScript友好语言指的是能够使用其他语法实现，但最终编译成js的语言。自从Node.js出现后，这种黑科技层出不穷。比如比较有名的coffee、typescript、babel（es）等。")]),v._v(" "),e("p",[v._v("CoffeeScript虽然也是JavaScript友好语言，但其语法借鉴ruby，崇尚极简，对于类型和OO机制上还是偏弱，而且这么多年也没发展起来，仍然是比较小众的活着。未来比例会越来越少的。")]),v._v(" "),e("p",[v._v("显然TypeScript会越来越好，TypeScript 的强大之处是要用过才知道的。")]),v._v(" "),e("ul",[e("li",[v._v("1）规模化编程，像Java那种，静态类型，面向对象，前端只有TypeScript能做到")]),v._v(" "),e("li",[v._v("2）亲爹是微软安德斯·海尔斯伯格，不知道此人的请看borland传奇去")]),v._v(" "),e("li",[v._v("3）开源，未来很好")]),v._v(" "),e("li",[v._v("4）组合拳：TypeScript + VSCode = 神器")])]),v._v(" "),e("p",[v._v("当下前端发展速度极快，以指数级的曲线增长。以前可能1年都不一定有一项新技术，现在可能每个月都有。大前端，Node全栈，架构演进等等都在快速变化。可以说，前端越复杂，有越多的不确定性，TypeScript的机会就越大。")]),v._v(" "),e("p",[v._v("4）再论面向对象")]),v._v(" "),e("p",[v._v("面向对象想用好也不容易的，而且js里有各种实现，真是让人眼花缭乱。")]),v._v(" "),e("ul",[e("li",[v._v("基于原型的写法，纵观JavaScript高级编程，就是翻来覆去的讲这个，这个很基础，但不是很好用。可以不用，但不可以不会。")]),v._v(" "),e("li",[v._v("自己写面向对象机制是最好的，但不是每个人都有这个能力的。好在es6规范出了更好一点的面向对象，通过class、extends、super关键字来定义类，已经明显好很多了，虽然还很弱，但起码勉强能用起来了。从面向过程走过来的同学，推荐这种写法，简单易用。但要注意面向对象要有面向对象的写法，要理解抽象，继承，封装，多态4个基本特征。如果想用好，你甚至还需要看一些设计模式相关的书。好在有《JavaScript设计模式》一书。Koa2里已经在用这种写法了。")]),v._v(" "),e("li",[v._v("js是脚本语言，解释即可执行。所以它的最大缺点是没有类型系统，这在规模化编程里是非常危险的，一个函数，传参就能玩死人。于是现在流行使用flow和typescript来做类型校验。flow只是工具，比较轻量级。而typescript是es6超集，给es6补充了类型系统和更完善的面向对象机制，所以大部分人都会对ts有好感，很有可能是未来的趋势。")])]),v._v(" "),e("p",[v._v("对于es6高级特性，我是比较保守的，一般node长期支持版本lts支持的我都让用，一些更新的特性我一般不让使用。根本lts版本保持一致就好。")]),v._v(" "),e("p",[v._v("我的团队现在是采用es6的面向对象写法开发，后面会一点一点转到typescript上的。熟练oo转到ts是非常容易的。")]),v._v(" "),e("h2",{attrs:{id:"node-js应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node-js应用场景","aria-hidden":"true"}},[v._v("#")]),v._v(" Node.js应用场景")]),v._v(" "),e("p",[v._v("《Node.js in action》一书里说，Node.js 所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为 Node.js 自身在 I/O 上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。")]),v._v(" "),e("p",[v._v("这话不假，但在今天来看，DIRT 还是范围小了。其实 DIRT 本质上说的 I/O 处理的都算，但随着大前端的发展，Node.js 已经不再只是 I/O 处理相关，而是更加的“Node”！")]),v._v(" "),e("p",[v._v("Node.js 使用场景主要分为4大类")]),v._v(" "),e("ul",[e("li",[v._v("1）跨平台：覆盖你能想到的面向用户的所有平台，传统的PC Web端，以及PC客户端 "),e("code",[v._v("nw.js/electron")]),v._v(" 、移动端 "),e("code",[v._v("cordova")]),v._v("、HTML5、"),e("code",[v._v("react-native")]),v._v("、"),e("code",[v._v("weex")]),v._v("，硬件 "),e("code",[v._v("ruff.io")]),v._v(" 等")]),v._v(" "),e("li",[v._v("2）Web应用开发：网站、Api、RPC服务等")]),v._v(" "),e("li",[v._v("3）前端：三大框架 React \\ "),e("code",[v._v("Vue")]),v._v(" \\ "),e("code",[v._v("Angular")]),v._v(" 辅助开发，以及工程化演进过程（使用"),e("code",[v._v("Gulp")]),v._v("/Webpack 构建 Web 开发工具）")]),v._v(" "),e("li",[v._v("4）工具："),e("code",[v._v("npm")]),v._v("上各种工具模块，包括各种前端预编译、构建工具 "),e("code",[v._v("Grunt")]),v._v(" / "),e("code",[v._v("Gulp")]),v._v("、脚手架，命令行工具，各种奇技淫巧等")])]),v._v(" "),e("p",[v._v("下面列出具体的 Node.js 的使用场景，以模块维度划分")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("分类")]),v._v(" "),e("th",[v._v("描述")]),v._v(" "),e("th",[v._v("相关模块")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("网站")]),v._v(" "),e("td",[v._v("类似于 "),e("code",[v._v("cnodejs.org")]),v._v(" 这样传统的网站")]),v._v(" "),e("td",[e("code",[v._v("Express")]),v._v(" / "),e("code",[v._v("Koa")])])]),v._v(" "),e("tr",[e("td",[v._v("Api")]),v._v(" "),e("td",[v._v("同时提供给移动端，PC，"),e("code",[v._v("H5")]),v._v(" 等前端使用的 "),e("code",[v._v("HTTP Api")]),v._v(" 接口")]),v._v(" "),e("td",[e("code",[v._v("Restify")]),v._v(" / "),e("code",[v._v("HApi")])])]),v._v(" "),e("tr",[e("td",[v._v("Api代理")]),v._v(" "),e("td",[v._v("为前端提供的，主要对后端Api接口进行再处理，以便更多的适应前端开发")]),v._v(" "),e("td",[e("code",[v._v("Express")]),v._v(" / "),e("code",[v._v("Koa")])])]),v._v(" "),e("tr",[e("td",[v._v("IM即时聊天")]),v._v(" "),e("td",[v._v("实时应用，很多是基于 "),e("code",[v._v("WebSocket")]),v._v("协议的")]),v._v(" "),e("td",[e("code",[v._v("Socket.io")]),v._v(" / "),e("code",[v._v("sockjs")])])]),v._v(" "),e("tr",[e("td",[v._v("反向代理")]),v._v(" "),e("td",[v._v("提供类似于 "),e("code",[v._v("nginx")]),v._v(" 反向代理功能，但对前端更友好")]),v._v(" "),e("td",[e("code",[v._v("anyproxy")]),v._v(" / "),e("code",[v._v("node-http-proxy")]),v._v(" / "),e("code",[v._v("hiproxy")])])]),v._v(" "),e("tr",[e("td",[v._v("前端构建工具")]),v._v(" "),e("td",[v._v("辅助前端开发，尤其是各种预编译，构建相关的工具，能够极大的提高前端开发效率")]),v._v(" "),e("td",[e("code",[v._v("Grunt")]),v._v(" / "),e("code",[v._v("Gulp")]),v._v(" / "),e("code",[v._v("Bower")]),v._v(" / "),e("code",[v._v("Webpack")]),v._v(" / "),e("code",[v._v("Fis3")]),v._v(" / "),e("code",[v._v("YKit")])])]),v._v(" "),e("tr",[e("td",[v._v("命令行工具")]),v._v(" "),e("td",[v._v("使用命令行是非常酷的方式，前端开发自定义了很多相关工具，无论是shell命令，node脚本，还是各种脚手架等，几乎每个公司\\小组都会自己的命令行工具集")]),v._v(" "),e("td",[e("code",[v._v("Cordova")]),v._v(" / "),e("code",[v._v("Shell.js")])])]),v._v(" "),e("tr",[e("td",[v._v("操作系统")]),v._v(" "),e("td",[v._v("有实现，但估计不太会有人用")]),v._v(" "),e("td",[e("code",[v._v("NodeOS")])])]),v._v(" "),e("tr",[e("td",[v._v("跨平台打包工具")]),v._v(" "),e("td",[v._v("使用 Web 开发技术开发PC客户端是目前最流行的方式，会有更多前端开发工具是采用这种方式的")]),v._v(" "),e("td",[v._v("PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的Cordova，即老的Phonegap，还有更加有名的一站式开发框架Ionicframework")])]),v._v(" "),e("tr",[e("td",[v._v("P2P")]),v._v(" "),e("td",[v._v("区块链开发、BT客户端")]),v._v(" "),e("td",[e("code",[v._v("webtorrent")]),v._v(" / "),e("code",[v._v("ipfs")])])]),v._v(" "),e("tr",[e("td",[v._v("编辑器")]),v._v(" "),e("td",[e("code",[v._v("Atom")]),v._v(" 和 "),e("code",[v._v("VSCode")]),v._v(" 都是基于 "),e("code",[v._v("electron")]),v._v(" 模块的")]),v._v(" "),e("td",[e("code",[v._v("electron")])])]),v._v(" "),e("tr",[e("td",[v._v("物联网与硬件")]),v._v(" "),e("td",[v._v("ruff.io和很多硬件都支持node sdk")]),v._v(" "),e("td",[e("code",[v._v("ruff")])])])])])])}],!1,null,null,null);_.default=d.exports}}]);